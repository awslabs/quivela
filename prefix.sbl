method MacI(mac) {
    new (const mac=mac,tg=0) {
        method tag(m) { tg[m] = mac.tag(m) } ;
        method verify(m,t) { t & tg[m] == t }
    }
};

// _e freshly encrypts iff _e ~ Enc(_e)

method Enc(e) {
    new (const e=e, d=0) {
        method enc(m) { c = e.enc(m) & !d[c] & d[c] = m & c };
        method dec(c) { e.dec(c) }
    }
};


// _e is a CPA-secure encryptor iff CpaC(_e) ~ CpaI(_e)

method CpaC(e) {
    new (const e=e,h=0) {
        method enc(m) { c = e.enc(m) & h[c]=1 & c };
        method dec(c) { h[c] & e.dec(c) }
    }
};

method CpaI(e) {
    new (const e=e,d=0) {
        method enc(m) { c = e.enc(zero(m)) & d[c] = m & c };
        method dec(c) { d[c] }
    }
};

// _e is an AEAD encryptor iff _e ~ AeadI(_e)

method AeadI(e) {
    new (const e=e,d=0) {
        method enc(a,m) { c = e.enc(a,zero(m)) & d[<a,c>] = m & c };
        method dec(a,c) { d[<a,c>] }
    }
};


// concrete encrypt-then-mac

method EtM(e,mac) {
    new (const e=e, const mac=mac) {
        method enc(a,m) {
            m &
            em = e.enc(m) &
            t = mac.tag(<a,em>) &
            <em,t>
        };
        method dec(a,c) {
            em = c^0;
            t = c^1;
            c &
            mac.verify(<a,em>,t) &
            e.dec(em)
        }
    }
};


// zero a bit-string (`& 0` ensures zero-length strings remain zero-length)
method zero(m) { m & 0 };
_e = adversary() ;
_mac = adversary() 